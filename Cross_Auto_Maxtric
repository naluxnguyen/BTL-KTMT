.data
# Result DATA1: .float 6.7 3.75 7.045 3.5 7.045 3.5 3.5 7.045
#https://www.overleaf.com/project/691062f244a125d24c484bfc
.data
desired: .float 1.5, 2.8, 3.2
input:   .float 1.2, 2.5, 3.0
NUM_SAMPLES: .word 3

# --- output arrays ---
crosscorr:   .space 12        # 3 floats
autocorr:    .space 12        # 3 floats
R:           .space 36        # 3x3 floats
SIZE_PRINT: .word 15
header_msg:  .asciiz "Data 2: \n"
 space: .asciiz " "
 newline: .asciiz " "
# Result DATADATA2 6.1333337 3.7866669 1.2800001 5.5633335 3.5 1.2 5.5633335 3.5 1.2 3.5 5.5633335 3.5 1.2 3.5 5.5633335
#https://www.overleaf.com/project/691064285c229c7376c617ca
# .include "data2.asm"

# --- helper floats ---	
zero_f:      .float 0.0
one_f:       .float 1.0
# TODO


.text
.globl main

main:
    # print header
    li   $v0, 4          # print string
    la   $a0, header_msg
    syscall
   ############ 

    lw $s7, NUM_SAMPLES     


    la $a0, input          
    la $a1, autocorr      
    move $a2, $s7        
    
    jal computeAutocorrelation
        # 1.  computeCrosscorrelation
    la $a0, desired       # $a0 = desired[]
    la $a1, input         # $a1 = input[]
    la $a2, crosscorr     # $a2 = crosscorr[]
    move $a3, $s7         # $a3 = N
    
    jal computeCrosscorrelation
    
    # 2. In  Cross-correlation
    
    la $a0, autocorr     
    la $a1,R        
    move $a2, $s7         
    
    jal createToeplitzMatrix
    

      
  
    li $s5, 0        
    

Print_Loop:
    bge $s5, $s7, End_Print_Loop 

    
    sll $t0, $s5, 2       
    add $t1, $a2, $t0     

    # Load gia tri: crosscorr[lag]
    lwc1 $f12, 0($t1)     

    # In gia tri(syscall 2: In float)
    li $v0, 2             
    syscall

    # 
    li $v0, 4
    la $a0, space
    syscall

    addi $s5, $s5, 1      # lag++
    j Print_Loop
    
End_Print_Loop:
    li $s5, 0      




 
    li $s3, 0          
# Vòng lap in ngoài (hàng)
Print_Loop_i:
    bge $s3, $s7, End_Program # Thoát neu i >= N

    li $s4, 0               # $s4 = j (c?t)
    
# Vòng lap in trong (c?t)
Print_Loop_j:
    bge $s4, $s7, Next_Row      # Thoát neu j >= N

    # Tính dia chi &R[i][j] 
    mul $t3, $s3, $s7           # t3 = i * N
    add $t4, $t3, $s4           # t4 = (i * N) + j
    sll $t5, $t4, 2             # t5 = Offset * 4
    add $t6, $a1, $t5           # t6 = &R[i][j] 

    # Load & In giá tri
    lwc1 $f12, 0($t6)           # $f12 = R[i][j]
    li $v0, 2                   # sys_print_float
    syscall

    # In dau cách
    li $v0, 4
    la $a0, space
    syscall

    addi $s4, $s4, 1            # j++
    j Print_Loop_j

Next_Row:
    # In xuong dòng sau m?i hàng
    li $v0, 4
    la $a0, newline
    syscall

    addi $s3, $s3, 1            # i++
    j Print_Loop_i
 Print_Autocorr_Loop:
    bge $s5, $s7, End_Print_Autocorr 
    
    sll $t0, $s5, 2     
    add $t1, $a1, $t0      


    lwc1 $f12, 0($t1)    


    li $v0, 2
    syscall

    li $v0, 4
    la $a0, space
    syscall

    addi $s5, $s5, 1   
    j Print_Autocorr_Loop
    
End_Print_Autocorr:
 li $v0, 4
    la $a0, newline
    syscall
End_Program:
    
	
    # --- create Toeplitz matrix ---
    ## TODO createToeplitzMatrix

    # --- print ---



   
    li $v0, 10
    syscall
# ---------------------------------------------------------
# computeAutocorrelation(input[], autocorr[], N)
# ---------------------------------------------------------
computeAutocorrelation:
    ## TODO
    # --- PROLOGUE: Luu trang thái và Bi?n vào Stack (6 words = 24 bytes) ---
    addi $sp, $sp, -24
    sw $ra, 0($sp)      # 0($sp): L?u ??a ch? tr? v?
    sw $a0, 4($sp)      # 4($sp): &signal[] (Sig_ptr)
    sw $a1, 8($sp)      # 8($sp): &autocorr[] (AC_ptr)
    sw $a2, 12($sp)     # 12($sp): N (N_val)

    # lag = 0
    li $t0, 0
    sw $t0, 16($sp)     # 16($sp): lag (Lag_idx)

    lw $t7, 4($sp)      # $t7 = &signal[] 
    lw $t8, 8($sp)      # $t8 = &autocorr[]
    lw $t9, 12($sp)     # $t9 = N 
    
    # CHUAN BI CHIA: Load N ($t9) và chuyen thành float ($f10)
    mtc1 $t9, $f10      # $f10 = N 
    cvt.s.w $f10, $f10  

# Vòng lap ngoài: for (lag = 0; lag < N; ++lag)
Loop_Lag:
    lw $t0, 16($sp)     # Tai lag ($t0)
    bge $t0, $t9, End_Lag_Loop 

    # Khoi tao $s = 0.0 (dùng $f2)
    li $t6, 0            
    mtc1 $t6, $f2        
    
    # Kh?i t?o n = 0
    li $t1, 0           
    sw $t1, 20($sp)     # 20($sp): n (N_idx)
    
    sub $t6, $t9, $t0   # $t6 = N - lag (s l?n l?p)

# Vòng l?p trong: for (n = 0; n < N - lag; ++n)
Loop_n:
    lw $t1, 20($sp)     # T?i n ($t1)
    bge $t1, $t6, End_n_Loop
    
    # Tính dia chi &signal[n]
    sll $t2, $t1, 2      # t2 = n * 4
    add $t3, $t7, $t2    # t3 = &signal[n] (dùng $t7 là Sig_ptr)
    
    # Tính dia chi &signal[n + lag]
    add $t4, $t1, $t0    # t4 = n + lag 
    sll $t4, $t4, 2      # t4 = (n + lag) * 4
    add $t5, $t7, $t4    # t5 = &signal[n + lag] (dùng $t7 là Sig_ptr)
    
    # Load giá tri
    lwc1 $f0, 0($t3)     # $f0 = signal[n]
    lwc1 $f1, 0($t5)     # $f1 = signal[n + lag]
    
    # Tính tích & tang tích luy
    mul.s $f4, $f0, $f1  
    add.s $f2, $f2, $f4  
    
    # Tang n và lu lai vào stack
    addi $t1, $t1, 1     
    sw $t1, 20($sp)
    j Loop_n

End_n_Loop:
    # CHUAN HÓA: Chia cho N
    div.s $f2, $f2, $f10 # $f2 = sum / N

    # Tính dia chi & Luu autocorr[lag]
    sll $t6, $t0, 2      # t6 = lag * 4 
    add $t5, $t8, $t6    # t5 = &autocorr[lag] (dùng $t8 là AC_ptr)
    swc1 $f2, 0($t5)     # autocorr[lag] = s / N

    # T?ng lag và l?u l?i vào stack
    addi $t0, $t0, 1     
    sw $t0, 16($sp)
    j Loop_Lag

End_Lag_Loop:
    # --- EPILOGUE: Khôi ph?c Stack và tra ve ---
    lw $ra, 0($sp)      
    addi $sp, $sp, 24   
    jr $ra


# ---------------------------------------------------------
# computeCrosscorrelation(desired[], input[], crosscorr[], N)
# ---------------------------------------------------------
computeCrosscorrelation:
    ## TODO

    addi $sp, $sp, -4    # Khoi tao Stack
    sw $ra, 0($sp)       # luu gia tr? tra ve

   
    move $s0, $a0        # $s0 = desired[]
    move $s1, $a1        # $s1 = input[]
    move $s2, $a2        # $s2 = crosscorr[]
    move $s3, $a3        # $s3 = N

    li $s4, 0            # $s4 = lag
    
    move $t9, $s3        # $t9 = N 
    mtc1 $t9, $f10       # $f10 = N 
    cvt.s.w $f10, $f10   # chuyen gia tri $f10 sang float (N.0)

#  for (lag = 0; lag < N; ++lag)
Loop_Lag1:
    bge $s4, $s3, End_Lag_Loop1 

   
    li $t9, 0            
    mtc1 $t9, $f2        # $f2 = s = 0.0

    li $s5, 0            # $s5 = n
    sub $t0, $s3, $s4    # $t0 = N - lag

#  for (n = 0; n < N - lag; ++n)
Loop_n1:
    bge $s5, $t0, End_n_Loop1 # thoat neu n >= N - lag

    #  &desired[n + lag]
    add $t1, $s5, $s4    
    sll $t2, $t1, 2      
    add $t3, $s0, $t2    
    
    # &input[n]
    sll $t4, $s5, 2      
    add $t5, $s1, $t4    

    # Load gia tri
    lwc1 $f0, 0($t3)     # $f0 = desired[n + lag]
    lwc1 $f1, 0($t5)     # $f1 = input[n]

    mul.s $f4, $f0, $f1  
    add.s $f2, $f2, $f4  

    addi $s5, $s5, 1     
    j Loop_n1

End_n_Loop1:
    #  Chia cho N
    div.s $f2, $f2, $f10 # $f2 = $f2 / N

    sll $t6, $s4, 2      
    add $t7, $s2, $t6    
    swc1 $f2, 0($t7)     # crosscorr[lag] = s / N

    addi $s4, $s4, 1     
    j Loop_Lag1

End_Lag_Loop1:
    lw $ra, 0($sp)       
    addi $sp, $sp, 4     
    jr $ra


# ---------------------------------------------------------
# createToeplitzMatrix(autocorr[], R[][], N)
# ---------------------------------------------------------
createToeplitzMatrix:
    ## TODO

    # --- PROLOGUE: L?u tr?ng thái và Bi?n vào Stack (6 words = 24 bytes) ---
    addi $sp, $sp, -24
    sw $ra, 0($sp)      # 0($sp): luu d?a chi tra ve

    # L?u các con tro và N 
    sw $a0, 4($sp)      # 4($sp): &autocorr[] (A_ptr)
    sw $a1, 8($sp)      # 8($sp): &R[][] (R_ptr)
    sw $a2, 12($sp)     # 12($sp): N (N_val)

    # Khoi tao i = 0
    li $t0, 0           
    sw $t0, 16($sp)     # 16($sp): i (row index)
    
    # T?i các h?ng s? vào thanh ghi $t 
    lw $t7, 4($sp)      # $t7 = &autocorr[]
    lw $t8, 8($sp)      # $t8 = &R[][]
    lw $t9, 12($sp)     # $t9 = N 

# Vòng lap ngoài: for (i = 0; i < N; ++i)
Loop_i_TM:
    lw $t0, 16($sp)     # T?i i ($t0)
    
    # Kiem tra dieu kien: bge i, N, End_i_Loop_TM
    bge $t0, $t9, End_i_Loop_TM

    # Khoi tao j = 0 
    li $t1, 0           
    sw $t1, 20($sp)     # 20($sp): Luu j = 0

# Vòng lap trong: for (j = 0; j < N; ++j)
Loop_j_TM:
    lw $t1, 20($sp)     # Tai j ($t1)
    
    # Kiem tra dieu ki?n: bge j, N, End_j_Loop_TM
    bge $t1, $t9, End_j_Loop_TM

    # 1. Tính lag = abs(i - j)
    sub $t2, $t0, $t1     # t2 = i - j
    
    bge $t2, $zero, Store_lag_TM_Continue 
    sub $t2, $zero, $t2     
Store_lag_TM_Continue:
    # $t2 là lag = abs(i - j)

    # 2. lay giá tri autocorr[lag]
    sll $t3, $t2, 2          # t3 = lag * 4 (offset byte)
    add $t4, $t7, $t3        # t4 = &autocorr[lag] 
    lwc1 $f0, 0($t4)         # $f0 = autocorr[lag]

    # 3. Tính di chi &R[i][j] (Row-Major Order)
    mul $t3, $t0, $t9        # t3 = i * N 
    add $t4, $t3, $t1        # t4 = (i * N) + j 
    
    sll $t5, $t4, 2          # t5 = Offset * 4 
    add $t6, $t8, $t5        # $t6 = &R[i][j]

    # 4. Luu ket qua: R[i][j] = $f0
    swc1 $f0, 0($t6)         

    # Tang j và luu lai vào stack
    addi $t1, $t1, 1         
    sw $t1, 20($sp)
    j Loop_j_TM

End_j_Loop_TM:
    # Tang i và luu lai vào stack
    addi $t0, $t0, 1         
    sw $t0, 16($sp)
    j Loop_i_TM

End_i_Loop_TM:
    # --- EPILOGUE: Khôi phac Stack và tra ve ---
    lw $ra, 0($sp)      
    addi $sp, $sp, 24   
    jr $ra
